---
title: "Data Journalism"
author: "Manh Ha Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import library

```{r}
library(tidyverse)
library(mapview)
library(sf)
library(terra)
library(foreach)
library(doParallel)
library(forecast)
library(geosphere)
library(broom)
library(shiny)
library(units)
library(prophet)
```

# List of all function

-   Note: all function are written based on the format of nsw data structure.

## Plot gas station on map given fuel type and date

-   Ensure columns correctly named long, lat, brand, price, fueltype, collection_date
-   Need further adjustment as station may sell many fuels type

```{r}
plot_points_on_map <- function(df, fueltype, collection_date) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Filter the data by collection date
  df <- df[df$collection_date == collection_date, ]
  
  # Convert lat and long to spatial points
  points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
  
  # Plot the data
  mapview(points_sdf, zcol = "price", label = points_sdf$brand)
}

```

## Average fuel type price for given postcode

-   Ensure postcode, fueltype, price correctly named

```{r}
avg_fuel_price <- function(df, fueltype, postcode) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Filter the data by postcode
  df <- df[df$postcode == postcode, ]
  
  # Calculate the average price
  avg_price <- mean(df$price)
  
  # Return the average price
  return(avg_price)
}

```

## Function to extract postcode from address

```{r}
# Extract postcode from address and mutate to postcode column
postcode <- function(df) {
  df <- df %>%
    mutate(postcode = str_extract(address, "\\d{4}"))
  return(df)
}
```

## Find closet gas station given a coordinates

-   Ensure long, lat, fueltype columns correctly named
-   Not suitable for large sets of data

```{r}
find_closest_gas_station <- function(df, fueltype, point_sdf) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Convert lat and long to spatial points
  points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
  
  # Find the closest gas station
  closest_gas_station <- st_nearest_feature(point_sdf, points_sdf)
  
  # Return the closest gas station (station code)
  return(df[closest_gas_station, ])
}
```

## Combine all csv files in a folder to a single dataframe

-   Assume format of data are the same within a folder

```{r}
combine_csv <- function(path) {
  # Record start time
  start_time <- Sys.time()
  
  # Get all csv files in the folder
  files <- list.files(path = path, pattern = "*.csv", full.names = TRUE)
  
  # Combine all csv files into a single dataframe
  df <- do.call(rbind, lapply(files, read_csv))
  
  # Record end time and print time taken
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # Return the dataframe
  return(df)
}

combine_csv_parallel <- function(path) {
  # Record start time
  start_time <- Sys.time()
  
  # Get all csv files in the folder
  files <- list.files(path = path, pattern = "*.csv", full.names = TRUE)
  
  # Register parallel backend
  cl <- makeCluster(detectCores())
  registerDoParallel(cl)
  
  # Combine all csv files into a single dataframe using foreach
  df <- do.call(rbind, foreach(i = files, .packages = "readr") %dopar% read_csv(i))
  
  # Stop the cluster
  stopCluster(cl)
  
  # Record end time and print time taken
  end_time <- Sys.time()
  print(end_time - start_time)
 
   # Return the dataframe
  return(df)
}


```

## Plot average price for a given fuel type by all brand over the time

```{r}
plot_avg_fuel_price_time <- function(df, fueltype) {
  
  # Filter the data for the specified fuel type
  df_fuel <- df[df$fueltype == fueltype,]
  
  # Calculate the average price per day
  df_avg <- df_fuel %>%
    group_by(collection_date) %>%
    summarise(avg_price = mean(price, na.rm = TRUE))
  
  # Create the plot
  p <- ggplot(df_avg, aes(x = collection_date, y = avg_price)) +
    geom_line() +
    geom_smooth() +
    labs(title = paste("Average Fuel Price Over Time:", fueltype),
         x = "Time",
         y = "Average Price")
  
  # Print the plot
  print(p)
}

```

## Auto rename columns

-   Rename "Longitude", "Lng" to "long"

-   Rename "Latitude", "Lat" to "lat"

-   Rename "Postcode" to "postcode"

-   Rename "FuelCode" to "fueltype"

-   Rename "Price" to "price"

-   Rename "BrandName" to "brand"

```{r}
auto_rename_columns <- function(df) {
  long_list <- c("Longitude", "Lng")  
  for (col_name in long_list) {
    if (col_name %in% colnames(df)) {
      df <- df %>%
        rename(long = all_of(col_name))
      break
    }
  }
  lat_list <- c("Latitude", "Lat")
  for (col_name in lat_list) {
    if (col_name %in% colnames(df)) {
      df <- df %>%
        rename(lat = all_of(col_name))
      break
    }
  }
  if ("Postcode" %in% colnames(df)) {
    df <- df %>%
      rename(postcode = all_of("Postcode"))
  }
  if ("Price" %in% colnames(df)) {
    df <- df %>%
      rename(price = all_of("Price"))
  }
  if ("FuelCode" %in% colnames(df)) {
    df <- df %>%
      rename(fueltype = all_of("FuelCode"))
  }
  if ("BrandName" %in% colnames(df)) {
    df <- df %>%
      rename(brand = all_of("BrandName"))
  }
  return(df)
}

```

## Selecting data given dataframe, fueltype, date and output to spatial object sf

-   Ensure state data of gas station are correctly format (fueltype, long, lat, collection_date)

```{r}
select_data <- function(data, fueltype, date) {
  # Select entries with specified fuel type
  data <- data[data$fueltype == fueltype, ]
  
  # Select entries with specified date
  data <- data[data$collection_date == date, ]
  
  # Convert to sf object
  data_sf <- st_as_sf(data, coords = c("long", "lat"), crs = 4326)
  
  return(data_sf)
}
```

## Method to calculate average distance an average person have to travel to the nearest gas station given a fuel type, date, and postcode

-   Ensure state data of gas station are correctly format (fueltype, long, lat, date, collection_date)

```{r}
calculate_distance <- function(state_fuel, postcode_sf, pop_density, fueltype, date, p_code, n_trial) {
  # Start time
  start_time <- Sys.time()
  
  # Select the postcode you are interested in
  postcode <- postcode_sf[postcode_sf$POA_CODE21 == p_code, ]

  # Generate random points
  n <- n_trial # number of points you want to generate
  random_points <- st_sample(postcode, size = n)
  # Convert to data frame for easier manipulation
  random_points_df <- as.data.frame(st_coordinates(random_points))
  # Convert to sf object
  random_points_sf <- st_as_sf(random_points_df, coords = c("X", "Y"), crs = 4326)

  # Extract population density values
  pop_density_values <- extract(pop_density, random_points_sf)

  # Add these values to your data frame
  random_points_sf$pop_density <- pop_density_values$aus_pd_2020_1km

  # Total population density in sample
  total_pop_density <- sum(random_points_sf$pop_density)

  # Divide each value by the total to get the proportion
  random_points_sf$pop_density <- random_points_sf$pop_density / total_pop_density

  # Select the fueltype you are interested in
  state_fuel_sf <- select_data(state_fuel, fueltype, date)

  # calculate nearest station for each point
  nearest_station_code <- sapply(1:n, function(i) {
    st_nearest_feature(random_points_sf[i,], state_fuel_sf)
  })

  # calculate distance between each point and its nearest station
  distance <- sapply(1:n, function(i) {
    st_distance(random_points_sf[i,], state_fuel_sf[nearest_station_code[i],])
  })

  distance <- as.data.frame(distance)
  
  # Assuming your data frame is named df
  distance$average <- cumsum(distance$distance) / seq_along(distance$distance)

  # Weighted average distance
  distance$average_weighted <- cumsum(distance$distance * random_points_sf$pop_density) / cumsum(random_points_sf$pop_density)
  
  # add spatial points to distance df (easier debug)
  distance$sf <- random_points_sf$geometry
  
  # End time
  end_time <- Sys.time()
  print(end_time - start_time)
  return(distance)
}

calculate_distance_parallel <- function(state_fuel, postcode_sf, pop_density, fueltype, date, p_code, n_trial) {
  # Start time
  start_time <- Sys.time()
  
  # Select the postcode you are interested in
  postcode <- postcode_sf[postcode_sf$POA_CODE21 == p_code, ]

  # Generate random points
  n <- n_trial # number of points you want to generate
  random_points <- st_sample(postcode, size = n)
  # Convert to data frame for easier manipulation
  random_points_df <- as.data.frame(st_coordinates(random_points))
  # Convert to sf object
  random_points_sf <- st_as_sf(random_points_df, coords = c("X", "Y"), crs = 4326)

  # Extract population density values
  pop_density_values <- extract(pop_density, random_points_sf)

  # Add these values to your data frame
  random_points_sf$pop_density <- pop_density_values$aus_pd_2020_1km

  # Total population density in sample
  total_pop_density <- sum(random_points_sf$pop_density)

  # Divide each value by the total to get the proportion
  random_points_sf$pop_density <- random_points_sf$pop_density / total_pop_density

  # Select the fueltype you are interested in
  state_fuel_sf <- select_data(state_fuel, fueltype, date)

  
  c1 <- makeCluster(detectCores())
  registerDoParallel(c1)
  # calculate nearest station for each point
  nearest_station_code <- foreach(i = 1:n, .combine = c, .packages = "sf") %dopar% {
    st_nearest_feature(random_points_sf[i,], state_fuel_sf)
  }
  stopCluster(c1)
  
  c2 <- makeCluster(detectCores())
  registerDoParallel(c2)
  # calculate distance between each point and its nearest station
  distance <- foreach(i = 1:n, .combine = c, .packages = "sf") %dopar% {
    st_distance(random_points_sf[i,], state_fuel_sf[nearest_station_code[i],])
  }
  stopCluster(c2)
  
  # Convert to data frame
  distance <- as.data.frame(distance)
  
  # Calculate average distance as n increases
  distance$average <- cumsum(distance$distance) / seq_along(distance$distance)

  # Weighted average distance
  distance$average_weighted <- cumsum(distance$distance * random_points_sf$pop_density) / cumsum(random_points_sf$pop_density)
  
  # add spatial points to distance df (easier debug)
  distance$sf <- random_points_sf$geometry
  
  # End time
  end_time <- Sys.time()
  print(end_time - start_time)
  
  return(distance)
}



```

## Calculate the average price of a given fuel in the last n days for each postcode in australia and return a data frame

```{r}
calculate_avg_postcode_fuelprice <- function(state_fuel, fueltype, n_days) {
  state_fuel <- state_fuel %>%
    filter(fueltype == fueltype) %>%
    filter(collection_date >= max(collection_date) - n_days & collection_date <= max(collection_date)) %>%
    group_by(postcode) %>%
    summarise(avg_price = mean(price, na.rm = TRUE))
  return(state_fuel)
}
```

# Import data

-   Population density from [Australia - Population Density - Humanitarian Data Exchange (humdata.org)](https://data.humdata.org/dataset/worldpop-population-density-for-australia?)

-   Road map from [AURIN](https://adp-access.aurin.org.au/dataset/osm-osm-roads-2020-na)

-   Postcode boundaries from [Digital boundary files \| Australian Bureau of Statistics (abs.gov.au)](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files)

```{r}
nsw <- combine_csv_parallel("fuel-prices/nsw")

nt <- combine_csv_parallel("fuel-prices/nt")

qld <- combine_csv_parallel("fuel-prices/qld")

sa <- combine_csv_parallel("fuel-prices/sa")

tas <- combine_csv_parallel("fuel-prices/tas")

postcode_sf <- read_sf(dsn = "postcode-shapefile",layer = "POA_2021_AUST_GDA94")

pop_density <- rast("aus_pd_2020_1km.tif")

road_map <- combine_csv_parallel("osm-road-map")

```

# Data cleaning & renaming

```{r}
# Mutate postcode columns
nsw <- postcode(nsw)
tas <- postcode(tas)

# Rename columns
nt <- auto_rename_columns(nt)
qld <- auto_rename_columns(qld)
sa <- auto_rename_columns(sa)

```

## NSW


### Map station and its price for a type of fuel across the state

For all fuel

-   further away from SYD, price tend to be higher?

-   further in land, more expensive the fuel?

-   along the coast, relatively equal?

```{r}
fueltype <- unique(nsw$fueltype)
plot_points_on_map(nsw,fueltype[1], "2023-9-23") 
```

### Fuel type vs price

-   Reccommend using EV consistently cheaper than fossil fuel
-   There exist extreme outliers for all fuel type except for EV and E85 (possible data error)

```{r}
nsw %>%
  ggplot(aes(x=fueltype,y=price)) +
  geom_boxplot() +
  labs(title="Price Distribution by Fuel Type from 2022-07-26 to 2023-11-12", x="Fuel", y="Price")
```

### Price Distribution by Brand for a type of fuel for a given day

-   Observe that even for same type of fuel and brand, there can be variations between location

```{r}
# Combustion fuel price distribution by brand
nsw %>%
  filter(fueltype != "EV") %>%   # remove EV as price is fixed
  filter(fueltype == "U91") %>%  # change fuel type
  filter(collection_date == "2023-8-21") %>%
  ggplot(aes(x=brand, y=price)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title="Price Distribution by Brand", x="Brand", y="Price")

```

### Fuel Type Popularity

-   Variations of petroleum are the most popular

```{r}
# Fuel Type Popularity
ggplot(nsw, aes(x=fueltype)) +
  geom_bar() +
  labs(title="Fuel Type Popularity", x="Fuel Type", y="Count")
```

### How far do you have to travel on average to fill up your car

-   Consider population density of each postcode to determine the weight of each postcode

-   Randomly distributed a corresponding number of representative points in each postcode

-   Distributed accordingly to the population density

-   Calculate average distance from each point to the nearest gas station

```{r}
# View the postcode shapefile
# mapview(postcode_sf, zcol = "POA_CODE21", legend = FALSE)

# plot random points on map with postcode
# plot(st_geometry(postcode))
# plot(random_points, add = TRUE, col = 'red', pch = 20)

p_code <- "2023"
n_trials <- 1000
# distance <- calculate_distance(nsw, postcode_sf, pop_density, "U91", "2023-10-10", p_code, n_trials)
distance2 <- calculate_distance_parallel(nsw, postcode_sf, pop_density, "U91", "2023-10-10", p_code, n_trials)

# Plotting the average
# ggplot(distance, aes(x = seq_along(average))) +
#  geom_line(aes(y = average), color = "blue") +
#  geom_line(aes(y = average_weighted), color = "red") +
#  labs(title = "Average distance to the closest gas station",
#       x = "n trials",
#       y = "Average distance (m)")

# Plotting the average calculated by parallel processing
ggplot(distance2, aes(x = seq_along(average))) +
  geom_line(aes(y = average), color = "blue") +
  geom_line(aes(y = average_weighted), color = "red") +
  labs(title = "Average distance to the closest gas station",
       x = "n trials",
       y = "Average distance (m)")

# print(paste("Average distance to the closest gas station in", p_code, "is", tail(distance$average, n = 1), "meters"))
# print(paste("Average weighted distance to the closest gas station in", p_code, "is", tail(distance$average_weighted, n = 1), "meters"))

print(paste("PP Average distance to the closest gas station in", p_code, "is", tail(distance2$average, n = 1), "meters"))
print(paste("PP Average weighted distance to the closest gas station in", p_code, "is", tail(distance2$average_weighted, n = 1), "meters"))

```

### Linear regression price \~ long + lat + fueltype + collection_date

-   contains influential cases that might need to ignore (might improve outcome of all assumption?)

```{r}
# linear regression to fit price ~ long lat fueltype
nsw_model_parallel <- lm(price ~ long+lat+fueltype+collection_date, data = nsw)

# Plot diagnostic
# plot(nsw_model_parallel)

# view model
summary(nsw_model_parallel)

```

### Plot average price for a given fueltype over time

```{r}
plot_avg_fuel_price_time(nsw, "U91")
```

### Experimental time series prediction

#### Using ETS

```{r}
fuel_data <- nsw %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(avg_price = mean(price, na.rm = TRUE)) %>%
  # only take 1 year of data
  filter(collection_date >= "2021-07-26" & collection_date <= "2023-07-26")
  
# Convert to time series object
fuel_ts <- ts(fuel_data$avg_price, frequency = 365.25)

# Apply ets and forecast
model <- ets(fuel_ts)
fc <- forecast(model, h = 30)

# Plot the forecast
plot(fc)


```

#### Using ARIMA

-   Seems more accurate given the data after 2023-11-12

```{r}
# Convert collection_date to Date class
nsw$collection_date <- as.Date(nsw$collection_date)

# Aggregate data to daily level
daily_data <- nsw %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(price = mean(price, na.rm = TRUE))

# Convert to time series
ts_data <- ts(daily_data$price, start = c(year(min(daily_data$collection_date)), month(min(daily_data$collection_date))), frequency = 365.25)

# Fit model
fit <- auto.arima(ts_data)

# Forecast
future <- forecast(fit, h = 30)

# Plot forecast
plot(future)

```

#### Using Facebook Prophet

```{r}
# Aggregate data to daily level
daily_data <- nsw %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(price = mean(price, na.rm = TRUE)) %>%
  rename(ds = collection_date, y = price)

m <- prophet(daily_data, yearly.seasonality = TRUE, weekly.seasonality = TRUE, daily.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 15)
forecast <- predict(m, future)
tail(forecast[c('ds', 'yhat', 'yhat_lower', 'yhat_upper')])
plot(m, forecast)
prophet_plot_components(m, forecast)

```

### Experimental shiny app (kinda working)

```{r}
ui <- fluidPage(
  selectInput("fueltype", "Choose a Fuel Type:", choices = unique(nsw$fueltype)),
  dateInput("collection_date", "Choose a Collection Date:", min = min(nsw$collection_date), max = max(nsw$collection_date)),
  plotOutput("map")
)

server <- function(input, output) {
  output$map <- renderPlot({
    df <- nsw[nsw$fueltype == input$fueltype, ]
    df <- df[df$collection_date == input$collection_date, ]
    points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
    mapview(points_sdf, zcol = "price", label = points_sdf$brand)
  })
}

# shinyApp(ui = ui, server = server)


```

## NT

### Map station and its price for a type of fuel across the state

```{r}
fueltype <- unique(nt$fueltype)
plot_points_on_map(nt,fueltype[1], "2023-9-23") 
```

### Fuel type vs price

-   There exist extreme outliers for DL, LAF, P95, P98 (possible data error)

```{r}
nt %>%
  ggplot(aes(x=fueltype,y=price)) +
  geom_boxplot() +
  labs(title="Price Distribution by Fuel Type from 2022-07-26 to 2023-11-12", x="Fuel", y="Price")
```

### Price Distribution by Brand for a type of fuel for a given day

-   Observe that even for same type of fuel and brand, there can be variations between location

```{r}
# Combustion fuel price distribution by brand
nt %>%
  filter(fueltype == "U91") %>%  # change fuel type
  filter(collection_date == "2023-8-21") %>%
  ggplot(aes(x=brand, y=price)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title="Price Distribution by Brand", x="Brand", y="Price")

```

### Fuel Type Popularity

-   Diesel is most popular fuel type

```{r}
# Fuel Type Popularity
ggplot(nt, aes(x=fueltype)) +
  geom_bar() +
  labs(title="Fuel Type Popularity", x="Fuel Type", y="Count")
```

### How far do you have to travel on average to fill up your car

-   Consider population density of each postcode to determine the weight of each postcode

-   Randomly distributed a corresponding number of representative points in each postcode

-   Distributed accordingly to the population density

-   Calculate average distance from each point to the nearest gas station

```{r}
# View the postcode shapefile
# mapview(postcode_sf, zcol = "POA_CODE21", legend = FALSE)

# plot random points on map with postcode
# plot(st_geometry(postcode))
# plot(random_points, add = TRUE, col = 'red', pch = 20)
# mapview(pop_density, zcol = "density")

p_code <- "0820"
n_trials <- 100
# distance <- calculate_distance(nt, postcode_sf, pop_density, "U91", "2023-10-10", p_code, n_trials)
distance2 <- calculate_distance_parallel(nt, postcode_sf, pop_density, "U91", "2023-10-10", p_code, n_trials)

# Plotting the average
# ggplot(distance, aes(x = seq_along(average))) +
#  geom_line(aes(y = average), color = "blue") +
#  geom_line(aes(y = average_weighted), color = "red") +
#  labs(title = "Average distance to the closest gas station",
#       x = "n trials",
#       y = "Average distance (m)")

# Plotting the average calculated by parallel processing
ggplot(distance2, aes(x = seq_along(average))) +
  geom_line(aes(y = average), color = "blue") +
  geom_line(aes(y = average_weighted), color = "red") +
  labs(title = "Average distance to the closest gas station",
       x = "n trials",
       y = "Average distance (m)")

# print(paste("Average distance to the closest gas station in", p_code, "is", tail(distance$average, n = 1), "meters"))
# print(paste("Average weighted distance to the closest gas station in", p_code, "is", tail(distance$average_weighted, n = 1), "meters"))

print(paste("PP Average distance to the closest gas station in", p_code, "is", tail(distance2$average, n = 1), "meters"))
print(paste("PP Average weighted distance to the closest gas station in", p_code, "is", tail(distance2$average_weighted, n = 1), "meters"))

```

### Linear regression price \~ long + lat + fueltype + collection_date

-   contains influential cases that might need to ignore (might improve outcome of all assumption?)

```{r}
# linear regression to fit price ~ long lat fueltype
nt_model_parallel <- lm(price ~ long+lat+fueltype+collection_date, data = nt)

# Plot diagnostic
# plot(nt_model_parallel)

# view model
summary(nt_model_parallel)

```

### Plot average price for a given fueltype over time

```{r}
plot_avg_fuel_price_time(nt, "U91")
```

### Experimental time series prediction

#### Using ETS

```{r}
fuel_data <- nt %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(avg_price = mean(price, na.rm = TRUE)) %>%
  # only take 1 year of data 
  filter(collection_date >= "2021-07-26" & collection_date <= "2023-07-26")

# Convert to time series object
fuel_ts <- ts(fuel_data$avg_price, frequency = 365.25)

# Apply ets and forecast
model <- ets(fuel_ts)
fc <- forecast(model, h = 30)

# Plot the forecast
plot(fc)


```

#### Using ARIMA

```{r}
# Convert collection_date to Date class
nt$collection_date <- as.Date(nt$collection_date)

# Aggregate data to daily level
daily_data <- nt %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(price = mean(price, na.rm = TRUE))

# Convert to time series
ts_data <- ts(daily_data$price, start = c(year(min(daily_data$collection_date)), month(min(daily_data$collection_date))), frequency = 365.25)

# Fit model
fit <- auto.arima(ts_data)

# Forecast
future <- forecast(fit, h = 30)

# Plot forecast
plot(future)

```

#### Using Facebook Prophet

```{r}
# Aggregate data to daily level
daily_data <- nt %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(price = mean(price, na.rm = TRUE)) %>%
  rename(ds = collection_date, y = price)

m <- prophet(daily_data, yearly.seasonality = TRUE, weekly.seasonality = TRUE, daily.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 15)
forecast <- predict(m, future)
tail(forecast[c('ds', 'yhat', 'yhat_lower', 'yhat_upper')])
plot(m, forecast)
prophet_plot_components(m, forecast)

```

### Experimental shiny app (kinda working)

```{r}
ui <- fluidPage(
  selectInput("fueltype", "Choose a Fuel Type:", choices = unique(nt$fueltype)),
  dateInput("collection_date", "Choose a Collection Date:", min = min(nt$collection_date), max = max(nt$collection_date)),
  plotOutput("map")
)

server <- function(input, output) {
  output$map <- renderPlot({
    df <- nt[nt$fueltype == input$fueltype, ]
    df <- df[df$collection_date == input$collection_date, ]
    points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
    mapview(points_sdf, zcol = "price", label = points_sdf$brand)
  })
}

# shinyApp(ui = ui, server = server)


```
