---
title: "Data Journalism"
author: "Manh Ha Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import library

```{r}
library(tidyverse)
library(mapview)
library(sf)
library(foreach)
library(doParallel)
library(forecast)
library(geosphere)
```

# List of all function

-   Note: all function are written based on the format of nsw_fuel structure.

## Plot gas station on map given fuel type and date

-   Ensure columns correctly named long, lat, brand
-   Need further adjustment as station may sell many fuels type

```{r}
plot_points_on_map <- function(df, fueltype, collection_date) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Filter the data by collection date
  df <- df[df$collection_date == collection_date, ]
  
  # Convert lat and long to spatial points
  points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
  
  # Plot the data
  mapview(points_sdf, zcol = "price", label = points_sdf$brand)
}

```

## Average fuel type price for given postcode

-   Ensure postcode, fueltype, price correctly named

```{r}
avg_fuel_price <- function(df, fueltype, postcode) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Filter the data by postcode
  df <- df[df$postcode == postcode, ]
  
  # Calculate the average price
  avg_price <- mean(df$price)
  
  # Return the average price
  return(avg_price)
}

```

## Function to extract postcode from address

```{r}
# Extract postcode from address and mutate to postcode column
postcode <- function(df) {
  df <- df %>%
    mutate(postcode = str_extract(address, "\\d{4}"))
  return(df)
}
```

## Find closet gas station given a coordinates

-   Ensure long, lat, fueltype columns correctly named

```{r}
find_closest_gas_station <- function(df, fueltype, lat, long) {
  # Filter the data by fuel type
  df <- df[df$fueltype == fueltype, ]
  
  # Convert lat and long to spatial points
  points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
  
  # Convert lat and long to spatial points
  point_sdf = st_as_sf(data.frame(long = long, lat = lat), coords = c("long", "lat"), crs = 4326)
  
  # Find the closest gas station
  closest_gas_station <- st_nearest_feature(point_sdf, points_sdf)
  
  # Return the closest gas station (station code)
  return(closest_gas_station)
}

```

## Combine all csv files in a folder to a single dataframe

-   Assume format of data are the same within a folder

```{r}
combine_csv <- function(path) {
  # Record start time
  start_time <- Sys.time()
  
  # Get all csv files in the folder
  files <- list.files(path = path, pattern = "*.csv", full.names = TRUE)
  
  # Combine all csv files into a single dataframe
  df <- do.call(rbind, lapply(files, read_csv))
  
  # Record end time and print time taken
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # Return the dataframe
  return(df)
}

combine_csv_parallel <- function(path) {
  # Record start time
  start_time <- Sys.time()
  
  # Get all csv files in the folder
  files <- list.files(path = path, pattern = "*.csv", full.names = TRUE)
  
  # Register parallel backend
  cl <- makeCluster(detectCores())
  registerDoParallel(cl)
  
  # Combine all csv files into a single dataframe using foreach
  df <- do.call(rbind, foreach(i = files, .packages = "readr") %dopar% read_csv(i))
  
  # Stop the cluster
  stopCluster(cl)
  
  # Record end time and print time taken
  end_time <- Sys.time()
  print(end_time - start_time)
 
   # Return the dataframe
  return(df)
}


```

## Plot average price for a given fuel type by all brand over the time

```{r}
plot_avg_fuel_price_time <- function(df, fueltype) {
  
  # Filter the data for the specified fuel type
  df_fuel <- df[df$fueltype == fueltype,]
  
  # Calculate the average price per day
  df_avg <- df_fuel %>%
    group_by(collection_date) %>%
    summarise(avg_price = mean(price, na.rm = TRUE))
  
  # Create the plot
  p <- ggplot(df_avg, aes(x = collection_date, y = avg_price)) +
    geom_line() +
    geom_smooth() +
    labs(title = paste("Average Fuel Price Over Time:", fueltype),
         x = "Time",
         y = "Average Price")
  
  # Print the plot
  print(p)
}

```

## Auto rename columns

```{r}
auto_rename_columns <- function(df) {
  long_list <- c("Longtitude", "Lng")  
  for (col_name in long_list) {
    if (col_name %in% colnames(df)) {
      df <- df %>%
        rename(long = all_of(col_name))
      break
    }
  }
  lat_list <- c("Latitude", "Lat")
  for (col_name in lat_list) {
    if (col_name %in% colnames(df)) {
      df <- df %>%
        rename(lat = all_of(col_name))
      break
    }
  }
  if ("Postcode" %in% colnames(df)) {
    df <- df %>%
      rename(postcode = all_of("Postcode"))
  }
  if ("Price" %in% colnames(df)) {
    df <- df %>%
      rename(price = all_of("Price"))
  }
  return(df)
}

```

# Import data

-   Change path to local path of fuel-prices/(states)

```{r}
nsw <- combine_csv_parallel("D:/UOA WORK/Summer Research/Data_Journalism_ASRS/fuel-prices/nsw")
nt <- combine_csv_parallel("D:/UOA WORK/Summer Research/Data_Journalism_ASRS/fuel-prices/nt")
qld <- combine_csv_parallel("D:/UOA WORK/Summer Research/Data_Journalism_ASRS/fuel-prices/qld")
sa <- combine_csv_parallel("D:/UOA WORK/Summer Research/Data_Journalism_ASRS/fuel-prices/sa")
tas <- combine_csv_parallel("D:/UOA WORK/Summer Research/Data_Journalism_ASRS/fuel-prices/tas")
```

## NSW

### Mutate postcode columns

```{r}
nsw <- postcode(nsw)
```

### Map station and its price for a type of fuel across the state

For all fuel

-   further away from SYD, price tend to be higher?

-   further in land, more expensive the fuel?

-   along the coast, relatively equal?

```{r}
fueltype <- unique(nsw$fueltype)
plot_points_on_map(nsw,fueltype[1], "2023-9-23") 
```

### Fuel type vs price

-   Reccommend using EV consistently cheaper than fossil fuel
-   There exist extreme outliers for all fuel type (except for EV and E85)

```{r}
nsw %>%
  ggplot(aes(x=fueltype,y=price)) +
  geom_boxplot() +
  labs(title="Price Distribution by Fuel Type from 2022-07-26 to 2023-11-12", x="Fuel", y="Price")
```

### Price Distribution by Brand for a type of fuel for a given day

-   Observe that even for same type of fuel and brand, there can be variations between location

```{r}
# Combustion fuel price distribution by brand
nsw %>%
  filter(fueltype != "EV") %>%   # remove EV as price is fixed
  filter(fueltype == "U91") %>%  # change fuel type
  filter(collection_date == "2023-8-21") %>%
  ggplot(aes(x=brand, y=price)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title="Price Distribution by Brand", x="Brand", y="Price")

```

### Fuel Type Popularity

-   Variations of petroleum are the most popular

```{r}
# Fuel Type Popularity
ggplot(nsw, aes(x=fueltype)) +
  geom_bar() +
  labs(title="Fuel Type Popularity", x="Fuel Type", y="Count")
```

### How far do you have to travel on average to fill up your car???

-   Consider population density of each postcode to determine the weight of each postcode??

-   Randomly distributed a corresponding number of representative points in each postcode???

-   Calculate average distance from each point to the nearest gas station???

-   Consider the number of gas station in each postcode???

-   Problem: how to map postcode border??? + density within each postcode can fluctuate btw sections???

```{r}
postcode_sf <- read_sf(dsn = "D:/UOA WORK/Summer Research/Data_Journalism_ASRS/postcode-shapefile",layer = "POA_2021_AUST_GDA94")
mapview(postcode_sf, zcol = "POA_CODE21", legend = FALSE)
```

### Linear regression price \~ long + lat + fueltype + collection_date

-   contains influential cases that might need to ignore (might improve outcome of all assumption?)

```{r}
# linear regression to fit price ~ long lat fueltype
nsw_model_parallel <- lm(price ~ long+lat+fueltype+collection_date, data = nsw)

# plot(nsw_model_parallel)

# view model
summary(nsw_model_parallel)

```

### Plot average price for a given fueltype over time

```{r}
plot_avg_fuel_price_time(nsw, "U91")
```

### Experimental time series prediction

#### Using ETS

```{r}
fuel_data <- nsw %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(avg_price = mean(price, na.rm = TRUE)) %>%
  # only take 1 year of data
  filter(collection_date >= "2021-07-26" & collection_date <= "2023-07-26")
  
# Convert to time series object
fuel_ts <- ts(fuel_data$avg_price, frequency = 365.25)

# Apply ets and forecast
model <- ets(fuel_ts)
fc <- forecast(model, h = 30)

# Plot the forecast
plot(fc)


```

#### Using ARIMA

-   Seems more accurate given the data after 2023-11-12

```{r}
# Load necessary libraries
library(forecast)
library(dplyr)

# Convert collection_date to Date class
nsw$collection_date <- as.Date(nsw$collection_date)

# Aggregate data to daily level
daily_data <- nsw %>%
  filter(fueltype == "U91") %>%
  group_by(collection_date) %>%
  summarise(price = mean(price, na.rm = TRUE))

# Convert to time series
ts_data <- ts(daily_data$price, start = c(year(min(daily_data$collection_date)), month(min(daily_data$collection_date))), frequency = 365.25)

# Fit model
fit <- auto.arima(ts_data)

# Forecast
future <- forecast(fit, h = 30)

# Plot forecast
plot(future)

```

### Experimental shiny app (kinda working)

```{r}
library(shiny)
library(mapview)

ui <- fluidPage(
  selectInput("fueltype", "Choose a Fuel Type:", choices = unique(nsw$fueltype)),
  dateInput("collection_date", "Choose a Collection Date:", min = min(nsw$collection_date), max = max(nsw$collection_date)),
  plotOutput("map")
)

server <- function(input, output) {
  output$map <- renderPlot({
    df <- nsw[nsw$fueltype == input$fueltype, ]
    df <- df[df$collection_date == input$collection_date, ]
    points_sdf = st_as_sf(df, coords = c("long", "lat"), crs = 4326)
    mapview(points_sdf, zcol = "price", label = points_sdf$brand)
  })
}

shinyApp(ui = ui, server = server)


```
